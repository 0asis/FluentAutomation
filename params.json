{"body":"## Fluent Automation API\r\n\r\n#### Getting Started\r\n\r\nThe intent of Fluent Automation is to simplify the task of creating automated tests for web applications.\r\n\r\n##### Installation\r\n\r\nOfficial releases of Fluent Automation for .NET are available via NuGet Package manager. They are provided as packages based on which underlying provider you wish to use. \r\n\r\n*PM> Install-Package FluentAutomation.SeleniumWebDriver*\r\n\r\nSeleniumWebDriver is the recommended provider. \r\n\r\n*PM> Install-Package FluentAutomation.WatiN*\r\n\r\nWatiN is provided as an alternative, but it only supports automating Internet Explorer.\r\n\r\n*PM> Install-Package FluentAutomation.PhantomJS*\r\n\r\nPhantomJS is currently in development, but has near feature parity with the other providers. It is intended for testing in environments where headless execution is preferred.\r\n\r\n##### Test Setup\r\n\r\nTo utilize Fluent Automation, all you need to do is create a class that inherits from our base test class and bootstrap your provider.\r\n\r\nThis can be done via constructor or test initialization methods. In the following sample, I will bootstrap the Selenium provider via constructor and open a browser to [Google](http://google.com/).\r\n\r\n    public class SampleTest : FluentAutomation.FluentTest\r\n    {\r\n    \tpublic SampleTest()\r\n    \t{\r\n    \t\tFluentAutomation.SeleniumWebDriver.Bootstrap();\r\n    \t}\r\n    \t\r\n    \t[Fact]\r\n    \tpublic void OpenGoogle()\r\n    \t{\r\n    \t\tI.Open(\"http://www.google.com/\");\r\n    \t\tI.Expect.Url(x => x.Contains(\"google.com\"));\r\n    \t}\r\n    }\r\n\r\nThe different providers have varying degrees of customization that can be applied during bootstrapping. For example, the Selenium provider can specify the web browser to target.\r\n\r\nConfiguration of various test-wide settings can be done using the static FluentAutomation.Settings class properties.\r\n\r\n    Settings.ScreenshotPath = @\"C:\\Results\\SampleTestSuite\";\r\n    Settings.ScreenshotOnFailedExpect = false;\r\n    Settings.ScreenshotOnFailedAction = false;\r\n    Settings.DefaultWaitTimeout = TimeSpan.FromSeconds(1);\r\n    Settings.DefaultWaitUntilTimeout = TimeSpan.FromSeconds(30);\r\n    Settings.MinimizeAllWindowsOnTestStart = true;\r\n\r\n#### Actions\r\nAll of the functionality of the API is available via sentence-like fluent method calls.\r\n\r\n#####Open\r\nOpen the browser, launch the provider and navigate to the specified URL.\r\n\r\n\tI.Open(\"http://www.google.com\");\r\n\r\n#####Click\r\nClick the specified point or element.\r\n\r\n\tI.Click(10, 10); // click by coordinate\r\n\tI.Click(\"button.submit\"); // click by selector\r\n\r\nOverloads support clicking relative to a selector.\r\n\r\n#####DoubleClick\r\nDoubleClick the specified point or element.\r\n\r\n\tI.DoubleClick(10, 10); // by coordinate.\r\n\tI.DoubleClick(\"button.submit\"); // by selector.\r\n\r\nOverloads support clicking relative to a selector.\r\n\r\n#####RightClick\r\nRightClick the specified point or element.\r\n\r\n\tI.RightClick(10, 10); // by coordinate.\r\n\tI.RightClick(\"button.submit\"); // by selector.\r\n\r\nOverloads support clicking relative to a selector.\r\n\r\n#####Hover\r\nHover over the specified point or element.\r\n\r\n\tI.Hover(10, 10); // by coordinate.\r\n\tI.Hover(\"button.submit\"); // by selector.\r\n\r\nOverloads support hovering relative to a selector.\r\n\r\n#####Focus\r\nSet focus on an element.\r\n\r\n\tI.Focus(\"button.submit\");\r\n\t\r\n#####Press\r\nUsing [Windows Forms SendKeys]() values, trigger a keypress event with the specified key.\r\n\r\n\tI.Press(\"{TAB}\"); // trigger a tab keypress event\r\n\t\r\n#####Type\r\nType a string one character at a time. Cannot be used with special keycodes such as {TAB}. Should be used in combination with other methods that set the focus inside of controls that cannot be automated, such as Flash or popup windows.\r\n\r\n\tI.Type(\"Test String\");\r\n\r\n#####Select\r\nSelect a value or values from a `<SELECT />` element. Overloads allow for selection via Value, Text or Index.\r\n\r\n\tI.Select(\"MN\").From(\"select#states\");\r\n\r\n####Advanced Actions\r\n\r\n#####Find / Find Multiple\r\n\r\nIn the rare scenarios that you need access to the element directly, you can use `I.Find/I.FindMultiple` to get a factory function that will locate and return the element to you.\r\n\r\nIt can be useful to do this in large test suites, where the same element is interacted with several times. Most Actions and Expects support a factory overload for the scenarios.\r\n\r\n\t\tvar notificationsDiv = I.Find(\"div#notifications\");\r\n\t\t\t\r\n\t\t// Verify no notifications on page.\r\n\t\tI.Expect.Count(0).Of(notificationsDiv);\r\n\r\n\t\t// Trigger Notification\r\n\t\tI.Click(\"button.trigger-notify\");\r\n\t\tI.Expect.Count(1).Of(notificationsDiv);\r\n\t\tI.Expect.Text(\"Button Clicked\").In(notificationsDiv);\r\n\r\n\t\t// Clicking notification removes from page\r\n\t\tI.Click(notificationsDiv);\r\n\t\tI.Expect.Count(0).Of(notificationsDiv);\r\n\r\nThis can be a useful optimization in tests that are very complex and interact with the same element multiple times. This is unnecessary in most cases.\r\n\r\nAnother use of `I.Find/I.FindMultiple` is to directly get to the element instance itself, in this case an instance that implements IElement.\r\n\r\n\tvar inputFunc = I.Find(\"input:eq(0)\");\r\n\tIElement input = inputFunc();\r\n\r\n\tif (input.IsText) {\r\n\t\t// do something\r\n\t}\r\n\r\nBy doing this, you lose some of the implicit retry logic for selectors. In general this is not something you want to do, but if you absolutely have no other choice, you can. This will also allow you to break the abstraction from the test provider by casting to the type used in that framework, Selenium's WebElement type for example. Again, not recommended.\r\n\r\n#####Take Screenshot\r\n\r\nGrab a screenshot of the current browser window and save it to disk. You must provide the name to save the file. The path it is saved in is configurable via Settings.ScreenshotPath.\r\n\r\n\tI.TakeScreenshot(string.Format(\"LoginScreen_{0}\", DateTime.Now.ToString()));\r\n\r\n#####Upload\r\n\r\nUsing a standard HTML File Input (`<input type='file' />`), upload a file to the server.\r\n\r\n\tI.Upload(\"input[type='file']:eq(0)\", @\"C:\\Penguins.jpg\");\r\n\r\nThe path must be absolute and point to the file you wish to upload. This has worked with several Flash-based uploaders as well.\r\n\r\n#####Drag & Drop\r\n\r\nProper Drag & Drop is supported in all providers. It can be specific to dragging a single selector to another, or dragging from an offset near a selector.\r\n\r\n\tI.Open(\"http://developer.yahoo.com/yui/examples/dragdrop/dd-groups.html\");\r\n\tI.Drag(\"#pt1\").To(\"#t2\");\r\n\tI.Drag(\"#pt2\").To(\"#t1\");\r\n\tI.Drag(\"#pb1\").To(\"#b1\");\r\n\tI.Drag(\"#pb2\").To(\"#b2\");\r\n\tI.Drag(\"#pboth1\").To(\"#b3\");\r\n\tI.Drag(\"#pboth2\").To(\"#b4\");\r\n\tI.Drag(\"#pt1\").To(\"#pt2\");\r\n\tI.Drag(\"#pboth1\").To(\"#pb2\");\r\n\r\n####Waits\r\n\r\nAny automated testing will require waits. Fluent supports both implicit and explicit waits. Implicit waits are used with Actions where a selector can't be located. Explicit waits can be used based on time or conditions.\r\n\r\n#####Wait\r\n\r\nWait for specific period, before continiuing test execution.\r\n\r\n\tI.Wait(1); // Wait 1 second\r\n\tI.Wait(TimeSpan.FromMilliseconds(500)); // Wait 500ms\t\r\n\r\n#####WaitUntil\r\n\r\nWait for a condition to be true, or an action to successfully pass without Exception.\r\n\r\nThis is very useful for pages with lots of AJAX where the implicit waits builtin to Actions just aren't good enough.\r\n\r\nWhen an `Expression<Action>` is provided, the expression will be re-evaluated until the timeout (Settings.DefaultWaitUntilTimeout) has passed or succeeds without throwing a FluentException. This means you can use any Action or Expect inside the expression.\r\n\r\n\tI.WaitUntil(() => I.Expect.Exists(\"#navbar\"));\r\n\t\r\nWhen an `Expression<Func<bool>>` is provided, the expression will be re-evaluated until the timeout has passed or the Func returns true.\r\n\r\n\tI.WaitUntil(() => {\r\n\t\tvar element = I.Find(\"#navbar\")();\r\n\t\treturn element != null;\r\n\t});\r\n\r\n#### Expects\r\n\r\nIn Fluent, you can expect that a certain state exists. If this state does not exist, an Exception of type `FluentExpectFailedException` will be thrown.\r\n\r\n**Text** Verify that an element matching the selector has the specified text in its innerHTML or value depending on type.\r\n\r\n\tI.Expect.Text(\"sup\").In(selector);\r\n\r\n**Value** Verify that an element matching the selector has the specified value. This works with `<input type='text' />`, `<textarea></textarea>` and `<select><option value='1'></select>`.\r\n\r\n\tI.Expect.Value(10).In(selector);\r\n\r\n**Exists** Verify that an element matching the selector exists. Alternative: `I.Expect.Count(0).Of(selector);`\r\n\r\n\tI.Expect.Exists(selector);\r\n\r\n**Class** Verify that the element matching the selector has the specified CSS class.\r\n\r\n\tI.Expect.Class(\"error\").On(selector);\r\n\r\n**Count** Verify that a specific count of elements matching the selector exist on the page.\r\n\r\n\tI.Expect.Count(1).Of(selector);\r\n\r\n**Url** Verify that the current open page URL matches the specified value.\r\n\r\n\tI.Expect.Url(\"http://www.google.com/\");\r\n\r\n**True / False** Verify that the expression returns either true or false.\r\n\r\n\tvar fieldFunc = I.Find(selector);\r\n\tI.Expect.True(() => fieldFunc().IsText);\r\n\tI.Expect.False(() => fieldFunc().IsSelect);\r\n\r\n**Throws** Verify that an expression causes an exception to be thrown.\r\n\r\n\tI.Expect.Throws(() => I.Expect.Class(\"error\").On(selector)); // selector does not have class\r\n\r\n#### Extending Fluent v2\r\n\r\nAs with previous versions of Fluent, extension methods are the preferred way of adding convenience methods. A very common example would be to add `I.Login()` to your tests.\r\n\r\n    public static void Login(this FluentAutomation.Interfaces.INativeActionSyntaxProvider I, string username, string password)\r\n    {\r\n        I.Open(PageUrls.LoginPage);\r\n        I.Enter(username).In(\"input#username\");\r\n        I.Enter(password).In(\"input#password\");\r\n        I.Click(\"button#login\");\r\n    }\r\n\r\nFrom this point, you'll be able to simply reference this extension method in your tests:\r\n\r\n\tI.Login(\"username\", \"password\");\r\n\r\nExpect syntax can be extended similarly.\r\n\r\n    public static void Checked(this FluentAutomation.ExpectSyntaxProvider expect, string selector)\r\n    {\r\n        expect.Count(0).Of(string.Format(\"{0}:checked\", selector));\r\n    }\r\n\r\nAdditionally, you can build new providers that implement `IExpectProvider, IFileStoreProvider` or `ICommandProvider` that can be injected with a custom Bootstrap method. We are working on making more internal interfaces accessible for injection soon. Let us know if you've got something interesting in mind.","tagline":"Simple Fluent API for UI Automation","google":"UA-35282988-1","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Fluent Automation"}