<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640" />

    <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
    <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>Fluentautomation by stirno</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/stirno/FluentAutomation">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>Fluentautomation</h1>
            <h2>Simple Fluent API for UI Automation</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/stirno/FluentAutomation/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/stirno/FluentAutomation/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h2>Fluent Automation API</h2>

<h4>Getting Started</h4>

<p>The intent of Fluent Automation is to simplify the task of creating automated tests for web applications.</p>

<h5>Installation</h5>

<p>Official releases of Fluent Automation for .NET are available via NuGet Package manager. They are provided as packages based on which underlying provider you wish to use. </p>

<p><em>PM&gt; Install-Package FluentAutomation.SeleniumWebDriver</em></p>

<p>SeleniumWebDriver is the recommended provider. </p>

<p><em>PM&gt; Install-Package FluentAutomation.WatiN</em></p>

<p>WatiN is provided as an alternative, but it only supports automating Internet Explorer.</p>

<p><em>PM&gt; Install-Package FluentAutomation.PhantomJS</em></p>

<p>PhantomJS is currently in development, but has near feature parity with the other providers. It is intended for testing in environments where headless execution is preferred.</p>

<h5>Test Setup</h5>

<p>To utilize Fluent Automation, all you need to do is create a class that inherits from our base test class and bootstrap your provider.</p>

<p>This can be done via constructor or test initialization methods. In the following sample, I will bootstrap the Selenium provider via constructor and open a browser to <a href="http://google.com/">Google</a>.</p>

<pre><code>public class SampleTest : FluentAutomation.FluentTest
{
    public SampleTest()
    {
        FluentAutomation.SeleniumWebDriver.Bootstrap();
    }

    [Fact]
    public void OpenGoogle()
    {
        I.Open("http://www.google.com/");
        I.Expect.Url(x =&gt; x.Contains("google.com"));
    }
}
</code></pre>

<p>The different providers have varying degrees of customization that can be applied during bootstrapping. For example, the Selenium provider can specify the web browser to target.</p>

<p>Configuration of various test-wide settings can be done using the static FluentAutomation.Settings class properties.</p>

<pre><code>Settings.ScreenshotPath = @"C:\Results\SampleTestSuite";
Settings.ScreenshotOnFailedExpect = false;
Settings.ScreenshotOnFailedAction = false;
Settings.DefaultWaitTimeout = TimeSpan.FromSeconds(1);
Settings.DefaultWaitUntilTimeout = TimeSpan.FromSeconds(30);
Settings.MinimizeAllWindowsOnTestStart = true;
</code></pre>

<h4>Actions</h4>

<p>All of the functionality of the API is available via sentence-like fluent method calls.</p>

<h5>Open</h5>

<p>Open the browser, launch the provider and navigate to the specified URL.</p>

<pre><code>I.Open("http://www.google.com");
</code></pre>

<h5>Click</h5>

<p>Click the specified point or element.</p>

<pre><code>I.Click(10, 10); // click by coordinate
I.Click("button.submit"); // click by selector
</code></pre>

<p>Overloads support clicking relative to a selector.</p>

<h5>DoubleClick</h5>

<p>DoubleClick the specified point or element.</p>

<pre><code>I.DoubleClick(10, 10); // by coordinate.
I.DoubleClick("button.submit"); // by selector.
</code></pre>

<p>Overloads support clicking relative to a selector.</p>

<h5>RightClick</h5>

<p>RightClick the specified point or element.</p>

<pre><code>I.RightClick(10, 10); // by coordinate.
I.RightClick("button.submit"); // by selector.
</code></pre>

<p>Overloads support clicking relative to a selector.</p>

<h5>Hover</h5>

<p>Hover over the specified point or element.</p>

<pre><code>I.Hover(10, 10); // by coordinate.
I.Hover("button.submit"); // by selector.
</code></pre>

<p>Overloads support hovering relative to a selector.</p>

<h5>Focus</h5>

<p>Set focus on an element.</p>

<pre><code>I.Focus("button.submit");
</code></pre>

<h5>Press</h5>

<p>Using <a href="">Windows Forms SendKeys</a> values, trigger a keypress event with the specified key.</p>

<pre><code>I.Press("{TAB}"); // trigger a tab keypress event
</code></pre>

<h5>Type</h5>

<p>Type a string one character at a time. Cannot be used with special keycodes such as {TAB}. Should be used in combination with other methods that set the focus inside of controls that cannot be automated, such as Flash or popup windows.</p>

<pre><code>I.Type("Test String");
</code></pre>

<h5>Select</h5>

<p>Select a value or values from a <code>&lt;SELECT /&gt;</code> element. Overloads allow for selection via Value, Text or Index.</p>

<pre><code>I.Select("MN").From("select#states");
</code></pre>

<h4>Advanced Actions</h4>

<h5>Find / Find Multiple</h5>

<p>In the rare scenarios that you need access to the element directly, you can use <code>I.Find/I.FindMultiple</code> to get a factory function that will locate and return the element to you.</p>

<p>It can be useful to do this in large test suites, where the same element is interacted with several times. Most Actions and Expects support a factory overload for the scenarios.</p>

<pre><code>    var notificationsDiv = I.Find("div#notifications");

    // Verify no notifications on page.
    I.Expect.Count(0).Of(notificationsDiv);

    // Trigger Notification
    I.Click("button.trigger-notify");
    I.Expect.Count(1).Of(notificationsDiv);
    I.Expect.Text("Button Clicked").In(notificationsDiv);

    // Clicking notification removes from page
    I.Click(notificationsDiv);
    I.Expect.Count(0).Of(notificationsDiv);
</code></pre>

<p>This can be a useful optimization in tests that are very complex and interact with the same element multiple times. This is unnecessary in most cases.</p>

<p>Another use of <code>I.Find/I.FindMultiple</code> is to directly get to the element instance itself, in this case an instance that implements IElement.</p>

<pre><code>var inputFunc = I.Find("input:eq(0)");
IElement input = inputFunc();

if (input.IsText) {
    // do something
}
</code></pre>

<p>By doing this, you lose some of the implicit retry logic for selectors. In general this is not something you want to do, but if you absolutely have no other choice, you can. This will also allow you to break the abstraction from the test provider by casting to the type used in that framework, Selenium's WebElement type for example. Again, not recommended.</p>

<h5>Take Screenshot</h5>

<p>Grab a screenshot of the current browser window and save it to disk. You must provide the name to save the file. The path it is saved in is configurable via Settings.ScreenshotPath.</p>

<pre><code>I.TakeScreenshot(string.Format("LoginScreen_{0}", DateTime.Now.ToString()));
</code></pre>

<h5>Upload</h5>

<p>Using a standard HTML File Input (<code>&lt;input type='file' /&gt;</code>), upload a file to the server.</p>

<pre><code>I.Upload("input[type='file']:eq(0)", @"C:\Penguins.jpg");
</code></pre>

<p>The path must be absolute and point to the file you wish to upload. This has worked with several Flash-based uploaders as well.</p>

<h5>Drag &amp; Drop</h5>

<p>Proper Drag &amp; Drop is supported in all providers. It can be specific to dragging a single selector to another, or dragging from an offset near a selector.</p>

<pre><code>I.Open("http://developer.yahoo.com/yui/examples/dragdrop/dd-groups.html");
I.Drag("#pt1").To("#t2");
I.Drag("#pt2").To("#t1");
I.Drag("#pb1").To("#b1");
I.Drag("#pb2").To("#b2");
I.Drag("#pboth1").To("#b3");
I.Drag("#pboth2").To("#b4");
I.Drag("#pt1").To("#pt2");
I.Drag("#pboth1").To("#pb2");
</code></pre>

<h4>Waits</h4>

<p>Any automated testing will require waits. Fluent supports both implicit and explicit waits. Implicit waits are used with Actions where a selector can't be located. Explicit waits can be used based on time or conditions.</p>

<h5>Wait</h5>

<p>Wait for specific period, before continiuing test execution.</p>

<pre><code>I.Wait(1); // Wait 1 second
I.Wait(TimeSpan.FromMilliseconds(500)); // Wait 500ms   
</code></pre>

<h5>WaitUntil</h5>

<p>Wait for a condition to be true, or an action to successfully pass without Exception.</p>

<p>This is very useful for pages with lots of AJAX where the implicit waits builtin to Actions just aren't good enough.</p>

<p>When an <code>Expression&lt;Action&gt;</code> is provided, the expression will be re-evaluated until the timeout (Settings.DefaultWaitUntilTimeout) has passed or succeeds without throwing a FluentException. This means you can use any Action or Expect inside the expression.</p>

<pre><code>I.WaitUntil(() =&gt; I.Expect.Exists("#navbar"));
</code></pre>

<p>When an <code>Expression&lt;Func&lt;bool&gt;&gt;</code> is provided, the expression will be re-evaluated until the timeout has passed or the Func returns true.</p>

<pre><code>I.WaitUntil(() =&gt; {
    var element = I.Find("#navbar")();
    return element != null;
});
</code></pre>

<h4>Expects</h4>

<p>In Fluent, you can expect that a certain state exists. If this state does not exist, an Exception of type <code>FluentExpectFailedException</code> will be thrown.</p>

<p><strong>Text</strong> Verify that an element matching the selector has the specified text in its innerHTML or value depending on type.</p>

<p><strong>Value</strong> Verify that an element matching the selector has the specified value. This works with <code>&lt;input type='text' /&gt;</code>, <code>&lt;textarea&gt;&lt;/textarea&gt;</code> and <code>&lt;select&gt;&lt;option value='1'&gt;&lt;/select&gt;</code>.</p>

<p><strong>Exists</strong> Verify that an element matching the selector exists. Alternative: <code>I.Expect.Count(0).Of(selector);</code></p>

<p><strong>Class</strong> Verify that the element matching the selector has the specified CSS class.</p>

<p><strong>Count</strong> Verify that a specific count of elements matching the selector exist on the page.</p>

<p><strong>Url</strong> Verify that the current open page URL matches the specified value.</p>

<p><strong>True / False</strong> Verify that the expression returns either true or false.</p>

<p><strong>Throws</strong> Verify that an expression causes an exception to be thrown.</p>

<h4>Extending Fluent v2</h4>

<p>As with previous versions of Fluent, extension methods are the preferred way of adding convenience methods. A very common example would be to add <code>I.Login()</code> to your tests.</p>

<pre><code>public static void Login(this FluentAutomation.Interfaces.INativeActionSyntaxProvider I, string username, string password)
{
    I.Open(PageUrls.LoginPage);
    I.Enter(username).In("input#username");
    I.Enter(password).In("input#password");
    I.Click("button#login");
}
</code></pre>

<p>From this point, you'll be able to simply reference this extension method in your tests:</p>

<pre><code>I.Login("username", "password");
</code></pre>

<p>Expect syntax can be extended similarly.</p>

<pre><code>public static void Checked(this FluentAutomation.ExpectSyntaxProvider expect, string selector)
{
    expect.Count(0).Of(string.Format("{0}:checked", selector));
}
</code></pre>

<p>Additionally, you can build new providers that implement <code>IExpectProvider, IFileStoreProvider</code> or <code>ICommandProvider</code> that can be injected with a custom Bootstrap method. We are working on making more internal interfaces accessible for injection soon. Let us know if you've got something interesting in mind.</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/stirno">stirno</a> can be found on <a href="https://github.com/stirno/FluentAutomation">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

    
  </body>
</html>
